//*****************************************************************************
//	
//*****************************************************************************

import <stats.slx>
import <h7>
import <proof3d>

#define LOCAL_SCOPES ON

module airport {

  int ID = 2;
	constant float TIME_SCALE = 1.0;
	constant float PA_TIME_SCALE = 2.0;
	set(Flight) ranked(descending priority) FLIGHT_QUEUE;
	rn_stream emergency, international, domestic, recreational, RNS_FLIGHTS, RNS_LANDING;
	constant float SHUTDOWN_TIME = 24.0 * 60.0 * TIME_SCALE; // One day
	control int SHUTDOWN = 0;
	facility CONCH;
	
	class Flight(int flight_id, int flight_killer, int flight_priority, float flight_arrival_time, float flight_landing_duration) {
		
		int id;
		int killer;
		int priority;
		float arrival_time;
		float landing_duration;
		
		initial {
			id = flight_id;
			killer = flight_killer;
			priority = flight_priority;
			arrival_time = flight_arrival_time;
			landing_duration = flight_landing_duration;
			place ME into FLIGHT_QUEUE;
		}
		
		actions {}
	}

	class Launcher(string(*) pa_flight_type_in, int priority_in, float mean_arrival_period_in, float mean_landing_duration_in) {
		string(100) pa_flight_type;
		int priority;
		float mean_arrival_period;
		float mean_landing_duration;
		int curr_id;
		float curr_flight_time;
		
		initial {
			pa_flight_type = pa_flight_type_in;
			priority = priority_in;
			mean_arrival_period = mean_arrival_period_in;
			mean_landing_duration = mean_landing_duration_in;
		}
		
		actions{
			forever {
				seize CONCH;
					curr_flight_time = rv_expo(RNS_FLIGHTS, mean_arrival_period * TIME_SCALE);
				release CONCH;
				advance curr_flight_time;
				if (time >= SHUTDOWN_TIME)
					break;
				seize CONCH;
					curr_id = ID++;
				release CONCH;
				PA_Create pa_flight_type curr_id;
				PA_Place curr_id on "AIRSPACE";
				advance 1.0 * TIME_SCALE;
				activate new Flight(curr_id, 0, priority, curr_flight_time, rv_expo(RNS_LANDING, mean_landing_duration * TIME_SCALE));
			}
		}
	}

	class runway(int runway_id) {
		float total_queueing_time, total_landing_time;
		int flights_landed = 0;
		int id = runway_id;
		string(7) runway_name = "RUNWAY";
		pointer(Flight) flight;

		actions {
			runway_name = runway_name cat ascii(id + 48);
			print(runway_name)"_______\n";
			forever {
				wait until (FLIGHT_QUEUE.size > 0);
				seize CONCH;
					if(FLIGHT_QUEUE.size > 0) {
						flight = first Flight in FLIGHT_QUEUE;
						remove flight from FLIGHT_QUEUE;
					} else {
						continue;
					}
				release CONCH;
				if(flight -> killer < 1) {
					total_queueing_time += time - flight -> arrival_time;
					PA_Place flight -> id on runway_name;
					total_landing_time -= time;
					advance flight -> landing_duration;
					total_landing_time += time; 
					++flights_landed;
					PA_Destroy flight -> id;
					destroy flight;
				} else {
					print (time, flights_landed, total_landing_time / time, total_queueing_time / flights_landed, ID)
						"Time _.__"
						"Flights Landed: _____|"
						"Runway Utilization: _.___|"
						"Mean Queueing Time/Flight: _.__ minutes"
						"ID: _\n\n";
					destroy flight;
					SHUTDOWN += 1;
					terminate;
				}
			}
		}
	}

	procedure init_launchers(string(*) argv[*]) {
		filedef infile input name = argv[1];
		string(100) flight_type;
		int priority;
		float mean_arrival_period, mean_landing_time;
		
		forever {
			read newline file=infile end=done (flight_type, priority, mean_arrival_period, mean_landing_time);
			activate new Launcher(flight_type, priority, mean_arrival_period, mean_landing_time);
		}
		done:;
	}

	procedure main(int argc, string(*) argv[*]) {
		int num_runways = 3;
		int incr1 = 0;
		PA_ATF argv[2];	// animation trace file (atf)
		PA_Set viewing_speed PA_TIME_SCALE;
		
		init_launchers(argv); //start launching flights
		fork priority 1{
			wait until (time > SHUTDOWN_TIME);
			for(incr1 = 1; incr1 <= num_runways; incr1++) {
				activate new Flight(-1, 1, 2, -1, -1);
			}
			terminate;
		}
		for(incr1 = 1; incr1 <= num_runways; incr1++) {
			activate new runway(incr1);
		}
		wait until (SHUTDOWN == num_runways);
		PA_End;
	}	// End of main
}
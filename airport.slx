//*****************************************************************************
//	
//*****************************************************************************

import <stats.slx>
import <h7>
import <proof3d>

#define LOCAL_SCOPES ON

module airport {

 	constant float TIME_SCALE = 1.0;
	constant float PA_TIME_SCALE = 2.0;
	constant int NUM_PROCESSES = 4;
	set(Objekt) ranked(descending priority) OBJEKT_QUEUES[NUM_PROCESSES];
	rn_stream RNS_OBJEKTS, RNS_PROCESSING;
	constant float SHUTDOWN_TIME = 24.0 * 60.0 * TIME_SCALE; // One day
	control int SHUTDOWN = 0;
	control int NUM_OBJEKTS;
	facility CONCH;

	class Objekt(int objekt_killer, int objekt_priority, float objekt_arrival_time) {
		
		static int num_objekts;
		int id;
		int killer;
		int priority;
		float arrival_time;
		
		initial {
			id = ++num_objekts;
			killer = objekt_killer;
			priority = objekt_priority;
			arrival_time = objekt_arrival_time;
		}
		actions {}
	}

	class Launcher(string(*) pa_objekt_type_in, int priority_in, float mean_arrival_period_in, int start_q_id_in) {
		string(100) pa_objekt_type;
		int priority;
		float mean_arrival_period;
		int start_q_id;
		float curr_objekt_time;
		pointer(Objekt) objekt;
		
		initial {
			pa_objekt_type = pa_objekt_type_in;
			priority = priority_in;
			mean_arrival_period = mean_arrival_period_in;
			start_q_id = start_q_id_in;
		}
		
		actions {
			forever {
				seize CONCH;
					curr_objekt_time = rv_expo(RNS_OBJEKTS, mean_arrival_period * TIME_SCALE);
				release CONCH;
				advance curr_objekt_time;
				if (time >= SHUTDOWN_TIME)
					break;
				seize CONCH;
					objekt = new Objekt(0, priority, curr_objekt_time);
					PA_Create pa_objekt_type objekt -> id;
					PA_Place objekt -> id on "QUEUE1";
					advance 1.0 * TIME_SCALE;
					place objekt into OBJEKT_QUEUES[start_q_id];
					++NUM_OBJEKTS;
				release CONCH;
			}
		}
	}

	class Processor(int process_id, int in_q_index, int out_q_index, float mean_processing_duration_in) {
		float total_queueing_time, total_processing_time;
		int objekts_processed = 0;
		int id = process_id;
		int in_q;
		int out_q;
		string(8) process_name = "PROCESS";
		pointer(Objekt) objekt;
		float mean_processing_duration;

		initial {
			in_q = in_q_index;
			out_q = out_q_index;
			mean_processing_duration = mean_processing_duration_in;
			process_name = process_name cat ascii(id + 48);
		}

		actions {
			forever {
				wait until (OBJEKT_QUEUES[in_q].size > 0);
				seize CONCH;
					if(OBJEKT_QUEUES[in_q].size > 0) {
						objekt = first Objekt in OBJEKT_QUEUES[in_q];
						remove objekt from OBJEKT_QUEUES[in_q];
					} else {
						continue;
					}
				release CONCH;
				if(objekt -> killer < 1) {
					advance 1.0;
					total_queueing_time += time - objekt -> arrival_time;
					PA_Place objekt -> id on process_name;
					total_processing_time -= time;
					advance rv_expo(RNS_PROCESSING, mean_processing_duration * TIME_SCALE);
					total_processing_time += time; 
					++objekts_processed;
					seize CONCH;
						if (out_q == NUM_PROCESSES + 1) {
							PA_Destroy objekt -> id;
							destroy objekt;
							--NUM_OBJEKTS;
						} else {
							place objekt in OBJEKT_QUEUES[out_q];
							PA_Place objekt -> id on "QUEUE" cat ascii(out_q + 48);
						}
					release CONCH;
				} else {
					seize CONCH;
						place objekt into OBJEKT_QUEUES[in_q];
					release CONCH;
					print (process_name, objekts_processed)
						"_"
						"Objekts Processed: _____\n\n";
					seize CONCH;
						SHUTDOWN += 1;
					release CONCH;
					break;
				}
			}
		}
	}

	procedure init_launchers(string(*) argv[*]) {
		filedef infile input name = argv[1];
		string(100) objekt_type;
		int priority;
		float mean_arrival_period, mean_processing_time;
		pointer(Objekt) objekt;
		
		forever {
			read newline file=infile end=done (objekt_type, priority, mean_arrival_period, mean_processing_time);
			activate new Launcher(objekt_type, priority, mean_arrival_period, 1);
		}
		done:;
	}

	procedure main(int argc, string(*) argv[*]) {
		int incr1 = 0;
		PA_ATF argv[2];	// animation trace file (atf)
		PA_Set viewing_speed PA_TIME_SCALE;
		int num_processors;
		int processors_per_process[NUM_PROCESSES] = {3, 2, 1, 4};

		init_launchers(argv); //start launching objekts
		for(incr1 = 1; incr1 <= NUM_PROCESSES; incr1++) {
			int i;
			for(i = 1; i <= processors_per_process[incr1]; i++) {
				activate new Processor(num_processors++, incr1, incr1 + 1, processors_per_process[incr1]);
			}
		}
		wait until (time > SHUTDOWN_TIME);
		wait until (NUM_OBJEKTS == 0);
		for(incr1 = 1; incr1 <= NUM_PROCESSES; incr1++) {
			place new Objekt(1, 1, -1) into OBJEKT_QUEUES[incr1];
		}
		wait until (SHUTDOWN == num_processors);
		PA_End;
	}	// End of main
}
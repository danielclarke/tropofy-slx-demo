import <h7>
import <proof3d>

#define LOCAL_SCOPES ON

module airport {

	constant float PA_TIME_SCALE = 2.0;
	constant int NUM_PROCESSES = 4;
	set(Box) ranked(descending priority) BOX_QUEUES[NUM_PROCESSES][2];
  int OPTIONAL_QUEUES[NUM_PROCESSES] = {0, 1, 0, 0};
  rn_stream RNS_BOXES, RNS_PROCESSING;
	constant float SHUTDOWN_TIME = 24.0 * 60.0; // One day
	control int SHUTDOWN = 0;
	control int NUM_BOXES;
	facility CONCH;

	class Box(string(*) box_color, int box_option, int box_priority,
            float box_arrival_time, float box_processing_time_factor, int box_killer) {
		static int num_boxes;
    string(30) color;
    int option;
		int id;
		int priority;
		float arrival_time;
		float processing_time_factor;
		int killer;
		initial {
			id = ++num_boxes;
      color = box_color;
      option = box_option;
			priority = box_priority;
			arrival_time = box_arrival_time;
			processing_time_factor = box_processing_time_factor;
			killer = box_killer;
		}
		actions {}
	}

  class Launcher(pointer(Box) in_box, int in_start_q_id) {
		int start_q_id;
		float curr_box_time;
    float mean_arrival_period;
		pointer(Box) box;
		initial {
      mean_arrival_period = in_box -> arrival_time;
      box = in_box;
			start_q_id = in_start_q_id;
		}
		actions {
			forever {
				seize CONCH;
					curr_box_time = rv_expo(RNS_BOXES, mean_arrival_period);
				release CONCH;
				advance curr_box_time;
				if (time >= SHUTDOWN_TIME)
					break;
				seize CONCH;
          //the in_box from which all are cloned is overwritten here
					box = new Box(box -> color, box -> option, box -> priority, curr_box_time, box -> processing_time_factor, 0);
					PA_Create box -> color box -> id;
					PA_Place box -> id on "QUEUE" cat ascii(start_q_id + 48);
					advance 1.0;
					place box into BOX_QUEUES[start_q_id][1];
					++NUM_BOXES;
				release CONCH;
			}
		}
	}

	class Processor(int process_id, int in_q_index, int out_q_index, float mean_processing_duration_in) {
		float total_queueing_time, total_processing_time;
		int boxes_processed = 0;
		int id = process_id;
		int in_q;
		int out_q;
		string(8) process_name;
		pointer(Box) box;
		float mean_processing_duration;
		initial {
			in_q = in_q_index;
			out_q = out_q_index;
			mean_processing_duration = mean_processing_duration_in;
			process_name = "PROCESS" cat ascii(id + 48);
		}
		actions {
			forever {
				wait until (BOX_QUEUES[in_q][1].size > 0);
				seize CONCH;
					if(BOX_QUEUES[in_q][1].size > 0) {
						box = first Box in BOX_QUEUES[in_q][1];
						remove box from BOX_QUEUES[in_q][1];
					} else {
						continue;
					}
				release CONCH;
				if(box -> killer < 1) {
					advance 1.0;
					total_queueing_time += time - box -> arrival_time;
					PA_Place box -> id on process_name;
					total_processing_time -= time;
					advance rv_expo(RNS_PROCESSING, mean_processing_duration * box -> processing_time_factor);
					total_processing_time += time;
					++boxes_processed;
          if (out_q == NUM_PROCESSES + 1) {
            seize CONCH;
              PA_Destroy box -> id;
              destroy box;
              --NUM_BOXES;
            release CONCH;
          } else {
            PA_Place box -> id on "EXITPROCESS" cat ascii(id + 48);
            advance 0.5;
            seize CONCH;
              place box in BOX_QUEUES[out_q][1];
            release CONCH;
            PA_Place box -> id on "QUEUE" cat ascii(out_q + 48);
          }
				} else {
					seize CONCH;
						place box into BOX_QUEUES[in_q][1];
						SHUTDOWN += 1;
					release CONCH;
					break;
				}
			}
		}
	}

	procedure init_launchers(string(*) fname) {
		filedef infile input name = fname;
    pointer(Box) box;
		forever {
      box = new Box("", 0, 0, 0, 0, 0);
			read newline file=infile end=done (box -> color, box -> option, box -> priority,
                                         box -> arrival_time, box -> processing_time_factor);
			activate new Launcher(box, 1);
		}
		done:;
	}

  procedure main(int argc, string(*) argv[*]) {
    int incr1 = 0;
    PA_ATF argv[3]; // animation trace file (atf)
    PA_Set viewing_speed PA_TIME_SCALE;
    int num_processors;
    int processors_per_process[NUM_PROCESSES] = {3, 2, 1, 4};

    init_launchers(argv[1]); //start launching boxes

		filedef infile input name = argv[2];
    for(incr1 = 1; incr1 <= NUM_PROCESSES; incr1++) {
      int i;
      int processor_number;
      int processing_time;
      for(i = 1; i <= processors_per_process[incr1]; i++) {
        read newline file=infile (processor_number, processing_time);
        activate new Processor(num_processors++, incr1, incr1 + 1, processing_time);
      }
    }
    wait until (time > SHUTDOWN_TIME);
    wait until (NUM_BOXES == 0);
    for(incr1 = 1; incr1 <= NUM_PROCESSES; incr1++) {
      place new Box("", 1, 1, 1, 0, 1) into BOX_QUEUES[incr1][1];
      place new Box("", 2, 1, 1, 0, 1) into BOX_QUEUES[incr1][2];
    }
    wait until (SHUTDOWN == num_processors);
    PA_End;
  }       // End of main
}

//*****************************************************************************
//	
//*****************************************************************************

import <stats.slx>
import <h7>
import <proof3d>

#define LOCAL_SCOPES ON

module airport {

  int ID = 2;
	constant float TIME_SCALE = 1.0;
	constant float PA_TIME_SCALE = 2.0;
	constant int NUM_PROCESSORS = 3;
	set(Objekt) ranked(descending priority) OBJEKT_QUEUES[NUM_PROCESSORS + 1];
	rn_stream emergency, international, domestic, recreational, RNS_OBJEKTS, RNS_PROCESSING;
	constant float SHUTDOWN_TIME = 24.0 * 60.0 * TIME_SCALE; // One day
	control int SHUTDOWN = 0;
	facility CONCH;

	class Objekt(int objekt_id, int objekt_killer, int objekt_priority, float objekt_arrival_time) {
		
		int id;
		int killer;
		int priority;
		float arrival_time;
		
		initial {
			id = objekt_id;
			killer = objekt_killer;
			priority = objekt_priority;
			arrival_time = objekt_arrival_time;
			place ME into OBJEKT_QUEUES[1];
		}
		
		actions {}
	}

	class Launcher(string(*) pa_objekt_type_in, int priority_in, float mean_arrival_period_in) {
		string(100) pa_objekt_type;
		int priority;
		float mean_arrival_period;
		int curr_id;
		float curr_objekt_time;
		
		initial {
			pa_objekt_type = pa_objekt_type_in;
			priority = priority_in;
			mean_arrival_period = mean_arrival_period_in;
		}
		
		actions {
			forever {
				seize CONCH;
					curr_objekt_time = rv_expo(RNS_OBJEKTS, mean_arrival_period * TIME_SCALE);
				release CONCH;
				advance curr_objekt_time;
				if (time >= SHUTDOWN_TIME)
					break;
				seize CONCH;
					curr_id = ID++;
				release CONCH;
				PA_Create pa_objekt_type curr_id;
				PA_Place curr_id on "ENTRY";
				advance 1.0 * TIME_SCALE;
				activate new Objekt(curr_id, 0, priority, curr_objekt_time);
			}
		}
	}

	class Processor(int process_id, int in_q_index, int out_q_index, float mean_processing_duration_in) {
		float total_queueing_time, total_processing_time;
		int objekts_processed = 0;
		int id = process_id;
		int in_q;
		int out_q;
		string(8) process_name = "PROCESS";
		pointer(Objekt) objekt;
		float mean_processing_duration;

		initial {
			in_q = in_q_index;
			out_q = out_q_index;
			mean_processing_duration = mean_processing_duration_in;
		}

		actions {
			process_name = process_name cat ascii(id + 48);
			forever {
				wait until (OBJEKT_QUEUES[in_q].size > 0);
				seize CONCH;
					if(OBJEKT_QUEUES[in_q].size > 0) {
						objekt = first Objekt in OBJEKT_QUEUES[in_q];
						remove objekt from OBJEKT_QUEUES[in_q];
					} else {
						continue;
					}
				release CONCH;
				if(objekt -> killer < 1) {
					total_queueing_time += time - objekt -> arrival_time;
					PA_Place objekt -> id on process_name;
					total_processing_time -= time;
					advance rv_expo(RNS_PROCESSING, mean_processing_duration * TIME_SCALE);
					total_processing_time += time; 
					++objekts_processed;
					seize CONCH;
						if (out_q == NUM_PROCESSORS) {
							destroy objekt;
						} else {
							place objekt in OBJEKT_QUEUES[out_q];
						}
					release CONCH;
				} else {
					print (time, objekts_processed, total_processing_time / time, total_queueing_time / objekts_processed, ID)
						"Time _.__"
						"Objekts Processed: _____|"
						"Runway Utilization: _.___|"
						"Mean Queueing Time/Objekt: _.__ minutes"
						"ID: _\n\n";
					seize CONCH;
					if (out_q == NUM_PROCESSORS) {
						destroy objekt;
						SHUTDOWN += 1;
					} else {
						place objekt in OBJEKT_QUEUES[out_q];
					};
					print(SHUTDOWN) "_\n"; 
					release CONCH;
					break;
				}
			}
		}
	}

	procedure init_launchers(string(*) argv[*]) {
		filedef infile input name = argv[1];
		string(100) objekt_type;
		int priority;
		float mean_arrival_period, mean_processing_time;
		
		forever {
			read newline file=infile end=done (objekt_type, priority, mean_arrival_period, mean_processing_time);
			activate new Launcher(objekt_type, priority, mean_arrival_period);
		}
		done:;
	}

	procedure main(int argc, string(*) argv[*]) {
		int incr1 = 0;
		PA_ATF argv[2];	// animation trace file (atf)
		PA_Set viewing_speed PA_TIME_SCALE;

		init_launchers(argv); //start launching objekts
		/*
		fork priority 1 {
			wait until (time > SHUTDOWN_TIME);
			for(incr1 = 1; incr1 <= NUM_PROCESSORS; incr1++) {
				activate new Objekt(-1, 1, 2, -1);
			}
			terminate;
		}*/
		for(incr1 = 1; incr1 <= NUM_PROCESSORS; incr1++) {
			activate new Processor(incr1, incr1, incr1 + 1, 5.0);
		}
		wait until (time > SHUTDOWN_TIME);
		for(incr1 = 1; incr1 <= NUM_PROCESSORS; incr1++) {
			activate new Objekt(-1, 1, 2, -1);
		}
		wait until (SHUTDOWN == 1);
		PA_End;
	}	// End of main
}
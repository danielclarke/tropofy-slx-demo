//*****************************************************************************
//	
//*****************************************************************************

import <stats.slx>
import <h7>
import <proof4>

module airport {
	
	class Flight {
		int flight_priority, kill_runway;
		int id;
		float flight_arrival_time, flight_landing_time;
	};

  int ID = 1;

	set(Flight) ranked(descending flight_priority) flight_queue;
	rn_stream emergency, international, domestic, recreational, landing;
	constant float shutdown_time = 365 * 24 * 60; // One year (in minutes)
	control int shutdown = 0;
	
	facility conch;
	
	int num_runways = 3;
	int incr1 = 0;

	procedure launch(rn_stream s, int p, float f_n, float f_x, float l_n, float l_x) {
		advance rv_uniform(s, f_n, f_x);
		pointer(Flight) flight;
		flight = new Flight;
		flight -> flight_arrival_time = time;
		flight -> flight_priority = p;
		flight -> flight_landing_time = rv_uniform(landing, l_n, l_x);

		place flight into flight_queue;
		
		seize conch;
		flight -> id = ID++;
		release conch;
		
		PA_Create	"Car" flight -> id;				// create Proof object
		PA_Place	flight -> id on "ENTRY";		// place on entry path
	}

	procedure main() {
		
		filedef timeinq output name = "timeinQ.lis";
		pointer(histogram) h;
		
		PA_ATF "CARWASH.atf";	// animation trace file (atf)
		
		pointer(puck) e_fork, i_fork, d_fork, r_fork;
		
		pointer(Flight) flight;

		e_fork = fork priority 1 {
			forever {
				launch(emergency, 10, 12.0 * 60.0, 24.0 * 60.0, 15.0, 30.0);
				if (time >= shutdown_time)
					terminate;
			}
		}
		
		i_fork = fork priority 1 {
			forever {
				launch(international, 9, 5.0, 10.0, 5.0, 12.0);
				if (time >= shutdown_time)
					terminate;
			}
		}
		
		d_fork = fork priority 1 {
			forever {
				launch(domestic, 8, 5.0, 10.0, 5.0, 9.0);
				if (time >= shutdown_time)
					terminate;
			}
		}
		
		r_fork = fork priority 1 {
			forever {
				launch(recreational, 7, 4 * 60.0, 8 * 60.0, 15.0, 20.0);
				if (time >= shutdown_time)
					terminate;
			}
		}
		
		fork priority 1{
			wait until (time > shutdown_time);
			for(incr1 = 1; incr1 <= num_runways; incr1++) {
				flight = new Flight;
				flight -> flight_priority = 2;
				flight -> kill_runway = 1;
				place flight into flight_queue;
			}
			terminate;
		}
		for(incr1 = 1; incr1 <= num_runways; incr1++) {
			activate new runway(incr1);
		}
		
		wait until (shutdown == num_runways);
		
		PA_End;

	}	// End of main

	class runway(int runway_id) {

		float total_queueing_time, total_landing_time;
		int flights_landed = 0;
		int id = runway_id;
		string(10) str_id;
		string(7) runway_name = "RUNWAY";

		pointer(Flight) flight;

		actions {

			runway_name = runway_name cat ascii(id + 48);
			print(runway_name)"_______\n";
			
			forever {
				
				wait until (flight_queue.size > 0);
				flight = first Flight in flight_queue;
				
				if(flight -> kill_runway < 1) {
					
					remove flight from flight_queue;
					total_queueing_time += time - flight -> flight_arrival_time;
					
					PA_Place	flight -> id on "CHAIN";		// place on the chain
					
					total_landing_time -= time;
					advance flight -> flight_landing_time;
					total_landing_time += time; 
					++flights_landed;	// count jobs out
					
					PA_Place	flight -> id on "EXIT";			// place on the exit path
					
					PA_Destroy flight -> id;						// destroy Proof object
					destroy flight;
					
				} else {
					
					remove flight from flight_queue;
					print (time, flights_landed, total_landing_time / time, total_queueing_time / flights_landed * 60, ID)

						"Time _.__"
						"Flights Landed: _____|"
						"Runway Utilization: _.___|"
						"Mean Queueing Time/Flight: _.__ minutes"
						"ID: _\n\n";

					destroy flight;
					shutdown += 1;
					terminate;
				}
			}
		}
	}

}